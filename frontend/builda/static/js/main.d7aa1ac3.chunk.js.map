{"version":3,"sources":["Components/InitializeChatComponent.js","config/index.js","WebSocket.js","Components/ChatComponent.js","App.js","serviceWorker.js","index.js"],"names":["InitializeChatComponent","props","usernameChangeHandler","event","setState","username","target","value","state","className","onSubmit","e","handleLogin","type","onChange","this","placeholder","required","Component","WebSocketService","callbacks","socketRef","instance","path","config","WebSocket","onmessage","socketNewMessage","data","onopen","console","log","onerror","message","onclose","connect","parsedData","JSON","parse","command","Object","keys","length","messages","sendMessage","from","text","messagesCallback","newMessageCallback","send","stringify","err","readyState","callback","socket","recursion","waitForSocketConnection","setTimeout","WebSocketInstance","getInstance","ChatComponent","scrollToBottom","chat","messagesEnd","maxScrollTop","scrollHeight","clientHeight","scrollTop","messageChangeHandler","sendMessageHandler","messageObject","currentUser","newChatMessage","preventDefault","renderMessages","map","i","key","id","author","content","initChatUser","addCallbacks","setMessages","bind","addMessage","fetchMessages","component","reverse","ref","el","App","loggedIn","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error"],"mappings":"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","file":"static/js/main.d7aa1ac3.chunk.js","sourcesContent":["import React, { Component } from 'react'\n\nclass InitializeChatComponent extends Component {\n    constructor(props) {\n        super(props)\n    \n        this.state = {\n             username : ''\n        }\n    }\n\n    usernameChangeHandler = (event) => {\n        this.setState({\n            username : event.target.value\n        });\n    }\n    \n    render() {\n        return (\n            <div className=\"login\">\n                <form onSubmit={(e) => this.props.handleLogin(e, this.state.username)} className=\"form\">\n                    <input \n                    type=\"text\"\n                    onChange={this.usernameChangeHandler}\n                    value={this.state.username}\n                    placeholder=\"Username\"\n                    required />\n                    \n                    <button className=\"submit\" type=\"submit\">\n                        Let's Chat!\n                    </button>\n                </form>\n            </div>\n        );\n    }\n}\n\nexport default InitializeChatComponent;","\nconst API_PATH = 'ws://localhost:8000/ws/chat';\n\nexport default {\n    API_PATH\n};","import config from './config';\n\nclass WebSocketService{\n    static instance = null; \n    callbacks = {};\n    \n    static getInstance(){\n        if (!WebSocketService.instance){\n            WebSocketService.instance = new WebSocketService();\n        }\n        return WebSocketService.instance;\n    }\n\n    constructor(){\n        this.socketRef = null;\n    }\n\n    connect(){\n        const path = config.API_PATH;\n        this.socketRef = new WebSocket(path);\n        \n        this.socketRef.onmessage = e => {\n            this.socketNewMessage(e.data);\n          };\n\n        this.socketRef.onopen = () => {\n            console.log(\"WebSocket open\");\n        };\n        \n        this.socketRef.onerror = e => {\n            console.log(e.message);\n        };\n\n        this.socketRef.onclose = () => {\n            console.log(\"WebSocket closed, restarting..\");\n            this.connect();\n        };   \n    }\n\n    socketNewMessage(data){\n        const parsedData = JSON.parse(data);\n        const command = parsedData.command;\n        if(Object.keys(this.callbacks).length === 0){\n            return;\n        }\n        if(command === 'messages'){\n            this.callbacks[command](parsedData.messages);\n        }\n        if(command === 'new_message'){\n            console.log(\"okay so this was called\")\n            this.callbacks[command](parsedData.message);\n        }\n    }\n\n    initChatUser(username){\n        this.sendMessage({command : 'init_chat', username : username});\n    }\n\n    fetchMessages(username){\n        this.sendMessage({command : 'fetch_messages', username : username});\n    }\n\n    newChatMessage(message){\n        this.sendMessage({command : 'new_message', from : message.from, text : message.text});\n    }\n\n    addCallbacks(messagesCallback, newMessageCallback){\n        this.callbacks['messages'] = messagesCallback;\n        this.callbacks['new_message'] = newMessageCallback;\n    }\n\n    sendMessage(data){\n        try{\n            console.log({...data})\n            this.socketRef.send(JSON.stringify({...data}))\n        }\n        catch(err){\n            console.log(err.message);\n        }\n    }\n    state(){\n        return this.socketRef.readyState;\n    }\n    waitForSocketConnection(callback){\n        const socket = this.socketRef;\n        const recursion = this.waitForSocketConnection;\n        setTimeout(\n            function(){\n                if(socket.readyState === 1){\n                    console.log(\"Connection is made\");\n                    if(callback != null){\n                        callback();\n                    }\n                    return;\n                }\n                else{\n                    console.log(\"Wait for connection..\");\n                    recursion(callback);\n                }\n            }, 1);\n    }\n}\n\nlet WebSocketInstance = WebSocketService.getInstance();\n\nexport default WebSocketInstance;","import React, { Component } from 'react';\nimport '../static/css/Chat.scss';\nimport WebSocketInstance from '../WebSocket';\n\nclass ChatComponent extends Component {\n    constructor(props) {\n        super(props)\n    \n        this.state = {\n            message : '',\n            messages : []\n        }\n        this.waitForSocketConnection(() => {\n            WebSocketInstance.initChatUser(this.props.currentUser);\n            WebSocketInstance.addCallbacks(this.setMessages.bind(this), this.addMessage.bind(this));\n            WebSocketInstance.fetchMessages(this.props.currentUser);\n        });\n    }\n    \n    waitForSocketConnection(callback) {\n        const component = this;\n        setTimeout(\n            function(){\n                if(WebSocketInstance.state() === 1){\n                    console.log('Connection is made');\n                    callback();\n                    return;\n                }\n                else{\n                    console.log(\"Waiting for connection..\");\n                    component.waitForSocketConnection(callback);\n                }\n            }, 100);\n    }\n\n    scrollToBottom = () => {\n        const chat = this.messagesEnd;\n        const scrollHeight = chat.scrollHeight;\n        const height = chat.clientHeight;\n        const maxScrollTop = scrollHeight - height;\n        chat.scrollTop = maxScrollTop > 0 ? maxScrollTop : 0;\n    }\n    addMessage(message) {\n        this.setState({\n            messages : [...this.state.messages, message]\n        });\n    }\n    \n    setMessages(messages){\n        this.setState ({\n            messages : messages.reverse()\n        });\n        console.log('This was called')\n    }\n    \n    messageChangeHandler = (event) => {\n        this.setState({\n            message : event.target.value\n        });\n    }\n\n    sendMessageHandler = (e, message) => {\n        const messageObject = {\n            from : this.props.currentUser,\n            text : message\n        };\n        WebSocketInstance.newChatMessage(messageObject);\n        \n        this.setState({\n            message : ''\n        });\n\n        e.preventDefault();\n    }\n\n    renderMessages = (messages) => {\n        const currentUser = this.props.currentUser;\n        return messages.map((message, i) => {\n            return (\n            <li key={message.id}className={message.author === currentUser ? 'me' : 'her'}\n            >\n                <h4 className='author'>\n                    {message.author}\n                </h4>\n                <p>\n                    {message.content}\n                </p>\n            </li>\n            );\n\n        });\n    }\n\n    componentDidMount() {\n        this.scrollToBottom();\n    }\n    componentDidUpdate() {\n        this.scrollToBottom();\n    }\n\n    render() {\n        const messages = this.state.messages;\n        const currentUser = this.props.currentUser;\n        return (\n            <div className='chat'>\n                <div className=\"container\">\n                    <h1>Chatting as {currentUser}</h1>\n                    <h3>Displaying only the recent 50 messages</h3>\n                    <ul ref={(el) => {this.messagesEnd = el; }}>\n                        {\n                            messages && \n                            this.renderMessages(messages)\n                        }\n                    </ul>\n                </div>\n                <div className=\"container message-form\">\n                    <form \n                    onSubmit={(e) => this.sendMessageHandler(e, this.state.message)}\n                    className=\"form\">\n                        <input \n                        type=\"text\"\n                        onChange={this.messageChangeHandler}\n                        value={this.state.message}\n                        placeholder=\"Start Typing\"\n                        required />\n                        <button type=\"submit\" className=\"submit\" value=\"Submit\">\n                            Send\n                        </button>\n                    </form>\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default ChatComponent;","import React, { Component } from 'react';\nimport './static/css/App.css';\nimport InitializeChatComponent from './Components/InitializeChatComponent';\nimport ChatComponent from './Components/ChatComponent';\nimport WebSocketInstance from './WebSocket';\n\nclass App extends Component{\n  constructor(props) {\n    super(props)\n    \n    this.state = {\n      username : '',\n      loggedIn : false\n    };\n  }\n  \n  handleLogin = (e, username) => {\n    e.preventDefault();\n    this.setState({loggedIn : true, username : username});\n    WebSocketInstance.connect();\n    console.log(this.state);\n  }\n\n  render(){\n    const { username,loggedIn } = this.state;\n    return (\n      <div className=\"App\">\n        {\n          loggedIn ?\n          <ChatComponent currentUser={username}\n          />\n          :\n          <InitializeChatComponent \n          handleLogin = {this.handleLogin}\n          />\n        }\n      </div>\n    );\n  }\n  \n}\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}